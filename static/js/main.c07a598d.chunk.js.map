{"version":3,"sources":["logo.svg","Components/ItemTypes.js","Components/ProcessingParametersContainer.jsx","Components/Card/Card.jsx","Algorithms.js","Components/AlgoContainer/AlgoContainer.jsx","Components/CanvasContainer/CanvasContainer.jsx","Constants.js","utils.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","ProcessingParametersContainer","cardID","processingOptions","onChange","Object","keys","map","option","TextField","key","id","label","type","placeholder","toString","variant","InputLabelProps","shrink","style","marginTop","Card","text","moveCard","findCard","deleteCard","updateCard","originalIndex","index","useDrag","item","ItemTypes","collect","monitor","isDragging","end","dropResult","getItem","droppedId","didDrop","drag","useDrop","accept","canDrop","hover","draggedId","overIndex","drop","opacity","ref","node","className","onClick","event","labels","target","parentElement","getElementsByTagName","i","length","htmlFor","property","textContent","console","debug","value","Number","parseInt","WrappedAlgorithms","_cannyEdgeDetection","src","dst","window","cv","Canny","lowerThreshold","upperThreshold","sobelApertureSize","moreAccurateGradient","_histogramEqualization","cvtColor","COLOR_RGBA2GRAY","equalizeHist","_medianFilter","medianBlur","kernelSize","_convertRGBToGray","_simpleBinaryThresholding","threshold","threshVal","THRESH_BINARY","_otsuThresholding","THRESH_OTSU","_adaptiveThresholding","adaptiveThreshold","maxValue","ADAPTIVE_THRESH_GAUSSIAN_C","C","executeWrappedAlgorithm","inputCanvas","outputCanvasID","functionToExecute","document","getElementById","imread","Mat","imshow","delete","InitialCardStates","algoID","functionIDLookup","functionToReturn","filter","state","AlgoContainer","cards","setCards","useState","potentialNewCard","setPotentialNewCard","atIndex","card","update","$splice","log","c","indexOf","$set","display","flexDirection","maxWidth","border","padding","marginBottom","backgroundColor","color","textAlign","textDecoration","InputLabel","NativeSelect","inputProps","cardState","evt","Button","preventDefault","algoId","$push","Math","max","apply","o","addCard","CanvasContainer","resolveOpenCVErrorNumber","err","isNaN","exceptionFromPtr","msg","ptr","split","Error","stack","replace","App","useEffect","webcam","webcamRef","current","interval","setInterval","originalCanvas","getCanvas","currentCanvas","functionToRun","error","clearInterval","React","useRef","audio","screenshotFormat","videoConstraints","width","height","facingMode","onUserMedia","DndProvider","backend","Backend","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c07a598d.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.ee7cd8ed.svg\";","/* the react-dnd library being used allows you to define multiple containers. Each container can be\r\nconfigured to only accept a certain type of item being dropped. One item can have one or more types.\r\n*/\r\nexport default {\r\n    CARD: 'card',\r\n}\r\n","import TextField from \"@material-ui/core/TextField\";\r\nimport React from \"react\";\r\n\r\nconst ProcessingParametersContainer = ({cardID, processingOptions, onChange}) => {\r\n    return (\r\n        <>\r\n            {Object.keys(processingOptions).map(option => (\r\n                <TextField\r\n                    key={cardID + '-' + option}\r\n                    id={cardID + '-' + option}\r\n                    label={option}\r\n                    type={\"number\"}\r\n                    placeholder={processingOptions[option].toString()}\r\n                    variant=\"outlined\"\r\n                    onChange={onChange}\r\n                    InputLabelProps={{\r\n                        shrink: true,\r\n                    }}\r\n                    style={{\r\n                        marginTop: \"10px\",\r\n\r\n                    }}\r\n                />\r\n            ))}\r\n        </>\r\n    );\r\n};\r\n\r\nexport default ProcessingParametersContainer;","import React from \"react\";\r\nimport {useDrag, useDrop} from \"react-dnd\";\r\nimport ItemTypes from \"../ItemTypes\";\r\nimport './Card.css';\r\nimport ProcessingParametersContainer from \"../ProcessingParametersContainer\";\r\n\r\nconst Card = ({id, text, moveCard, findCard, deleteCard, processingOptions, updateCard}) => {\r\n    const originalIndex = findCard(id).index;\r\n    const [{isDragging}, drag] = useDrag({\r\n        item: {type: ItemTypes.CARD, id, originalIndex},\r\n        collect: monitor => ({\r\n            isDragging: monitor.isDragging()\r\n        }),\r\n        end: (dropResult, monitor) => {\r\n            const {id: droppedId, originalIndex} = monitor.getItem();\r\n            const didDrop = monitor.didDrop();\r\n            if (!didDrop) {\r\n                moveCard(droppedId, originalIndex);\r\n            }\r\n        }\r\n    });\r\n    const [, drop] = useDrop({\r\n        accept: ItemTypes.CARD,\r\n        canDrop: () => false,\r\n        hover({id: draggedId}) {\r\n            if (draggedId !== id) {\r\n                const {index: overIndex} = findCard(id);\r\n                moveCard(draggedId, overIndex);\r\n            }\r\n        }\r\n    });\r\n    const opacity = isDragging ? 0 : 1;\r\n\r\n    return (\r\n        <div\r\n            ref={node => drag(drop(node))}\r\n            style={{opacity}}\r\n            className={'card'}\r\n        >\r\n            {text}\r\n            <span\r\n                className={'delete-button'}\r\n                onClick={() => {\r\n                    deleteCard(id);\r\n                }}>\r\n                <p\r\n                    className=\"fa fa-trash\"\r\n                ></p>\r\n            </span>\r\n            <br/>\r\n            <div\r\n                className={\"processing-parameters\"}\r\n            >\r\n                <ProcessingParametersContainer\r\n                    cardID={id}\r\n                    processingOptions={processingOptions}\r\n                    onChange={\r\n                        (event) => {\r\n                            let labels = event.target.parentElement.parentElement.getElementsByTagName('label');\r\n                            for (let i = 0; i < labels.length; i++) {\r\n                                if (labels[i].htmlFor === event.target.id) {\r\n                                    let property = labels[i].textContent;\r\n                                    console.debug(\r\n                                        `received a change with the value: ${event.target.value} of type ${typeof (event.target.value)} for property ${property}`);\r\n                                    updateCard(\r\n                                        id, property, Number.parseInt(event.target.value)\r\n                                    );\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                >\r\n                </ProcessingParametersContainer>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\nexport default Card;","// contains image processing algorithms\r\n// TODO: consider a way to make it more scalable to add new algorithms\r\nconst WrappedAlgorithms = {\r\n    _cannyEdgeDetection: function _cannyEdgeDetection(src, dst, processingOptions) {\r\n        window.cv.Canny(src, dst, processingOptions.lowerThreshold,\r\n            processingOptions.upperThreshold,\r\n            processingOptions.sobelApertureSize,\r\n            processingOptions.moreAccurateGradient);\r\n    },\r\n\r\n    _histogramEqualization: function _histogramEqualization(src, dst, processingOptions) {\r\n        window.cv.cvtColor(src, src, window.cv.COLOR_RGBA2GRAY, 0); // need to leave this here even if its grayscale for some reason otherwise will crash\r\n        window.cv.equalizeHist(src, dst);\r\n    },\r\n\r\n    _medianFilter: function _medianFilter(src, dst, processingOptions) {\r\n        window.cv.medianBlur(src, dst, processingOptions.kernelSize);\r\n    },\r\n\r\n    _convertRGBToGray: function _convertRGBToGray(src, dst, processingOptions) {\r\n        window.cv.cvtColor(src, dst, window.cv.COLOR_RGBA2GRAY, 0);\r\n    },\r\n\r\n    _simpleBinaryThresholding: function _binaryThresholding(src, dst, processingOptions) {\r\n        window.cv.threshold(src, dst, processingOptions.threshVal, 255, window.cv.THRESH_BINARY);\r\n    },\r\n\r\n    _otsuThresholding: function _otsuThresholding(src, dst, processingOptions) {\r\n        window.cv.cvtColor(src, src, window.cv.COLOR_RGBA2GRAY, 0); // need to leave this here even if its grayscale for some reason otherwise will crash\r\n        // thresh value does not matter for otsu,\r\n        // so a placeholder value of 69 is placed.\r\n        window.cv.threshold(src, dst, 69, 255, window.cv.THRESH_OTSU);\r\n    },\r\n\r\n    _adaptiveThresholding: function _adaptiveThresholding(src, dst, processingOptions) {\r\n        window.cv.cvtColor(src, src, window.cv.COLOR_RGBA2GRAY, 0);\r\n        window.cv.adaptiveThreshold(src, dst,\r\n            processingOptions.maxValue,\r\n            window.cv.ADAPTIVE_THRESH_GAUSSIAN_C,\r\n            window.cv.THRESH_BINARY,\r\n            processingOptions.kernelSize,\r\n            processingOptions.C);\r\n    }\r\n};\r\n\r\nexport default WrappedAlgorithms;\r\n\r\nexport function executeWrappedAlgorithm(inputCanvas, outputCanvasID, processingOptions, functionToExecute) {\r\n    console.debug(`---- Executing algorithm: ${functionToExecute} ----`);\r\n    console.debug(\"showing some debug information for the algorithm to execute\");\r\n    console.debug(\"input canvas:\");\r\n    console.debug(inputCanvas);\r\n    console.debug(\"output canvas:\");\r\n    console.debug(document.getElementById(outputCanvasID));\r\n    console.debug(\"function to execute:\");\r\n    console.debug(functionToExecute);\r\n    console.debug(\"================\");\r\n    let src = window.cv.imread(inputCanvas);\r\n    let dst = new window.cv.Mat();\r\n\r\n    functionToExecute(src, dst, processingOptions);\r\n    window.cv.imshow(outputCanvasID, dst);\r\n\r\n    src.delete();\r\n    dst.delete();\r\n\r\n    return document.getElementById(outputCanvasID);\r\n}\r\n\r\nexport const InitialCardStates = [\r\n    {\r\n        id: 1,\r\n        algoID: 1,\r\n        text: \"RGB to Grayscale\",\r\n        processingOptions: {}\r\n    },\r\n    {\r\n        id: 2,\r\n        algoID: 2,\r\n        text: \"Histogram Equalization\",\r\n        processingOptions: {}\r\n    },\r\n    {\r\n        id: 3,\r\n        algoID: 3,\r\n        text: \"Simple Image Thresholding\",\r\n        processingOptions: {\r\n            threshVal: 127,\r\n        }\r\n    },\r\n    {\r\n        id: 4,\r\n        algoID: 4,\r\n        text: \"Median Filtering\",\r\n        processingOptions: {\r\n            kernelSize: 5,\r\n        }\r\n    },\r\n    {\r\n        id: 5,\r\n        algoID: 5,\r\n        text: \"Canny Edge Detection\",\r\n        processingOptions: {\r\n            lowerThreshold: 50,\r\n            upperThreshold: 100,\r\n            sobelApertureSize: 3,\r\n            moreAccurateGradient: false,\r\n        }\r\n    },\r\n    {\r\n        id: 6,\r\n        algoID: 6,\r\n        text: \"Otsu Binarization\",\r\n        processingOptions: {},\r\n    },\r\n    {\r\n        id: 7,\r\n        algoID: 7,\r\n        text: \"Adaptive Thresholding\",\r\n        processingOptions: {\r\n            maxValue: 200,\r\n            kernelSize: 3,\r\n            C: 2,\r\n        },\r\n    }\r\n];\r\n\r\n// look up the function to run, its label, and its possible options based on the id of the card.\r\n// (rationale for not adding these functions into the card directly is to have human-readable label for each algo card)\r\nexport function functionIDLookup(algoID) {\r\n    let functionToReturn = () => {\r\n    };\r\n    let label = InitialCardStates.filter(state => state.algoID === algoID)[0].text;\r\n    let processingOptions = InitialCardStates.filter(state => state.algoID === algoID)[0].processingOptions;\r\n    switch (algoID) {\r\n        case 1: {\r\n            functionToReturn = WrappedAlgorithms._convertRGBToGray;\r\n            break;\r\n        }\r\n        case 2: {\r\n            functionToReturn = WrappedAlgorithms._histogramEqualization;\r\n            break;\r\n        }\r\n        case 3: {\r\n            functionToReturn = WrappedAlgorithms._simpleBinaryThresholding;\r\n            break;\r\n        }\r\n        case 4: {\r\n            functionToReturn = WrappedAlgorithms._medianFilter;\r\n            break;\r\n        }\r\n        case 5: {\r\n            functionToReturn = WrappedAlgorithms._cannyEdgeDetection;\r\n            break;\r\n        }\r\n        case 6: {\r\n            functionToReturn = WrappedAlgorithms._otsuThresholding;\r\n            break;\r\n        }\r\n        case 7: {\r\n            functionToReturn = WrappedAlgorithms._adaptiveThresholding;\r\n            break;\r\n        }\r\n        default: {\r\n        }\r\n    }\r\n    return [functionToReturn, label, processingOptions];\r\n}\r\n","import React, {useState} from \"react\";\r\nimport {DndProvider, useDrop} from \"react-dnd\";\r\nimport Card from \"../Card/Card\";\r\nimport update from \"immutability-helper\";\r\nimport ItemTypes from \"../ItemTypes\";\r\nimport {functionIDLookup, InitialCardStates} from \"../../Algorithms\";\r\nimport ProcessingParametersContainer from \"../ProcessingParametersContainer\";\r\nimport NativeSelect from \"@material-ui/core/NativeSelect\";\r\nimport InputLabel from \"@material-ui/core/InputLabel\";\r\nimport Button from \"@material-ui/core/Button\";\r\n\r\nconst AlgoContainer = ({cards, setCards}) => {\r\n    // AlgoContainer should have its own state for defining a new card to be added\r\n    let [potentialNewCard, setPotentialNewCard] = useState({\r\n        algoID: 1,\r\n        processingOptions: {}\r\n    });\r\n\r\n\r\n    // add a new processing unit into the pipeline\r\n    const addCard = (algoId, processingOptions) => {\r\n        let [, label,] = functionIDLookup(algoId);\r\n        console.debug(algoId);\r\n        console.debug(typeof algoId);\r\n        console.debug(processingOptions);\r\n        setCards(\r\n            update(cards, {\r\n                $push: [{\r\n                    id: Math.max.apply(Math, cards.map(function (o) {\r\n                        return o.id + 1;\r\n                    })),\r\n                    algoID: algoId,\r\n                    text: label,\r\n                    processingOptions: processingOptions,\r\n                }]\r\n            })\r\n        );\r\n    };\r\n\r\n    const moveCard = (id, atIndex) => {\r\n        const {card, index} = findCard(id);\r\n        setCards(\r\n            update(cards, {\r\n                $splice: [[index, 1], [atIndex, 0, card]]\r\n            })\r\n        );\r\n    };\r\n\r\n    const deleteCard = (id) => {\r\n        const {card, index} = findCard(id);\r\n        console.log(`aiyoh ${id} kena delete`);\r\n        setCards(\r\n            update(cards, {\r\n                $splice: [[index, 1]]\r\n            })\r\n        );\r\n    };\r\n\r\n    const findCard = id => {\r\n        const card = cards.filter(c => `${c.id}` === id)[0];\r\n        return {\r\n            card,\r\n            index: cards.indexOf(card)\r\n        };\r\n    };\r\n\r\n    const updateCard = (id, property, value) => {\r\n        const {card, index} = findCard(id);\r\n        console.debug(`got a value of ${value} for property ${property} in updateCard`);\r\n\r\n        setCards(\r\n            update(cards, {\r\n                [index]: {\r\n                    processingOptions: {\r\n                        [property]:\r\n                            {$set: value}\r\n                    }\r\n                }\r\n            })\r\n        );\r\n    };\r\n\r\n    const [, drop] = useDrop({\r\n            accept: ItemTypes.CARD,\r\n            drop: () => {\r\n            }\r\n        }\r\n    );\r\n\r\n    return (\r\n        <div style={{\r\n            display: \"flex\",\r\n            flexDirection: \"column\",\r\n            maxWidth: \"30vw\",\r\n        }}>\r\n            <div ref={drop}\r\n                 className={\"drag-and-drop-container\"}>\r\n                <h2>Algorithms to run on input video (in order from top to bottom)</h2>\r\n                {cards.map(card => (\r\n                    <Card\r\n                        key={card.id}\r\n                        id={`${card.id}`}\r\n                        text={card.text}\r\n                        moveCard={moveCard}\r\n                        findCard={findCard}\r\n                        deleteCard={deleteCard}\r\n                        processingOptions={card.processingOptions}\r\n                        updateCard={updateCard}\r\n                    />\r\n                ))}\r\n            </div>\r\n            {/* TODO: move the below to another component*/}\r\n            <form style={{\r\n                marginTop: \"50px\",\r\n                border: \"1px gray\",\r\n                padding: \"0.5rem 1rem\",\r\n                marginBottom: \".5rem\",\r\n                backgroundColor: \"white\",\r\n                color: \"black\",\r\n                display: \"flex\",\r\n                flexDirection: \"column\",\r\n                textAlign: \"left\",\r\n            }}>\r\n                <p style={{\r\n                    textDecoration: \"underline\",\r\n                    textAlign: \"center\",\r\n                }}>Add a new processing card</p>\r\n                <InputLabel shrink htmlFor=\"select-new-algo\">\r\n                    Algorithm Options\r\n                </InputLabel>\r\n                <NativeSelect\r\n                    onChange={event => {\r\n                        let algoID = Number.parseInt(event.target.value);\r\n                        let [, , processingOptions] = functionIDLookup(algoID);\r\n                        console.debug(\"setting new card with parameters:\");\r\n                        console.debug(`algoID: ${algoID} of type ${typeof algoID}`);\r\n                        console.debug(\"processing options:\");\r\n                        console.debug(processingOptions);\r\n                        setPotentialNewCard({algoID, processingOptions});\r\n                    }} inputProps={{\r\n                    id: 'select-new-algo',\r\n                }}\r\n                >\r\n                    {InitialCardStates.map((cardState, id) => {\r\n                        return (\r\n                            <option key={id} value={cardState.algoID}>{cardState.text}</option>\r\n                        )\r\n                    })}\r\n                </NativeSelect>\r\n                <label htmlFor=\"options-for-algo\"></label>\r\n                <div id={\"options-for-algo\"}>\r\n                    <ProcessingParametersContainer\r\n                        cardID={-1}\r\n                        processingOptions={potentialNewCard.processingOptions}\r\n                        onChange={(evt) => {\r\n                        }}\r\n                    ></ProcessingParametersContainer>\r\n                </div>\r\n                <Button\r\n                    variant=\"contained\"\r\n                    style={{marginTop: \"30px\"}}\r\n                    id={\"add-algo\"}\r\n                    onClick={(evt) => {\r\n                        evt.preventDefault();\r\n                        console.debug(potentialNewCard.algoID);\r\n                        console.debug(potentialNewCard.processingOptions);\r\n                        addCard(\r\n                            potentialNewCard.algoID,\r\n                            potentialNewCard.processingOptions\r\n                        )\r\n                    }\r\n                    }\r\n                >\r\n                    Add new algorithm\r\n                </Button>\r\n            </form>\r\n        </div>\r\n    );\r\n};\r\nexport default AlgoContainer;","import React from \"react\";\r\nimport \"../../Constants\";\r\nimport {INTERMEDIATE_OUTPUT_PREFIX} from \"../../Constants\";\r\n\r\nconst CanvasContainer = ({cards}) => {\r\n\r\n    return (\r\n        <div className={\"daPipeline\"}>\r\n            {cards.map((card, index) => (\r\n                <canvas\r\n                    key={INTERMEDIATE_OUTPUT_PREFIX + index}\r\n                    id={INTERMEDIATE_OUTPUT_PREFIX + index}\r\n                >\r\n                </canvas>\r\n            ))}\r\n        </div>\r\n    );\r\n};\r\nexport default CanvasContainer;","export const INTERMEDIATE_OUTPUT_PREFIX = \"intermediate-output-\";\r\nexport const DELAY = 500;","// convert openCV error number into error message\r\nexport function resolveOpenCVErrorNumber(err) {\r\n    if (typeof err === 'undefined') {\r\n        err = '';\r\n    } else if (typeof err === 'number') {\r\n        if (!isNaN(err)) {\r\n            if (typeof cv !== 'undefined') {\r\n                err = 'Exception: ' + window.cv.exceptionFromPtr(err).msg;\r\n            }\r\n        }\r\n    } else if (typeof err === 'string') {\r\n        let ptr = Number(err.split(' ')[0]);\r\n        if (!isNaN(ptr)) {\r\n            if (typeof cv !== 'undefined') {\r\n                err = 'Exception: ' + window.cv.exceptionFromPtr(ptr).msg;\r\n            }\r\n        }\r\n    } else if (err instanceof Error) {\r\n        err = err.stack.replace(/\\n/g, '<br>');\r\n    }\r\n    return(err);\r\n}","import React, {useEffect, useState} from 'react';\r\nimport logo from './logo.svg';\r\nimport './App.css';\r\n\r\n// for webcam\r\nimport Webcam from \"react-webcam\";\r\n\r\n// for cards and drag-and-drop\r\nimport {DndProvider} from 'react-dnd'\r\nimport Backend from 'react-dnd-html5-backend'\r\nimport AlgoContainer from \"./Components/AlgoContainer/AlgoContainer\";\r\n\r\n// for the intermediate output\r\nimport CanvasContainer from \"./Components/CanvasContainer/CanvasContainer\";\r\n\r\n// for the image processing algorithms\r\nimport {INTERMEDIATE_OUTPUT_PREFIX, DELAY} from \"./Constants\";\r\nimport {resolveOpenCVErrorNumber} from \"./utils.js\";\r\nimport {executeWrappedAlgorithm, functionIDLookup, InitialCardStates} from \"./Algorithms\";\r\n\r\nfunction App() {\r\n    // life saviour: https://upmostly.com/tutorials/setinterval-in-react-components-using-hooks\r\n    useEffect(() => {\r\n        if (!window.webcam)\r\n            window.webcam = webcamRef.current;\r\n\r\n        if (window.cv)\r\n            console.log('opencv loaded');\r\n        else {\r\n            console.log('opencv not loaded, will exit');\r\n            return;\r\n        }\r\n\r\n        const interval = setInterval(() => {\r\n\r\n            const originalCanvas = window.webcam.getCanvas();\r\n\r\n            if (!originalCanvas) {\r\n                return;\r\n            }\r\n\r\n            // something like dequeueing\r\n            let currentCanvas = originalCanvas;\r\n            // console.log(cards);\r\n            // console.log(cards.length);\r\n            for (let i = 0; i < cards.length; i++) {\r\n                // console.log(i);\r\n                let card = cards[i];\r\n\r\n                // for debug purposes\r\n                console.debug(\"----- CURRENT CARD STATUSES ----\");\r\n                console.debug(\"CURRENT CANVAS TO INPUT FROM:\");\r\n                console.debug(currentCanvas);\r\n                console.debug(\"CURRENT CANVAS TO OUTPUT TO:\");\r\n                console.debug(INTERMEDIATE_OUTPUT_PREFIX + i);\r\n                console.debug(\"CURRENT SET OF PROCESSING OPTIONS\");\r\n                console.debug(card.processingOptions);\r\n                console.debug(\"///////////\");\r\n\r\n                // do sth based on card id\r\n                try {\r\n                    let [functionToRun,,] = functionIDLookup(card.algoID);\r\n                    currentCanvas = executeWrappedAlgorithm(currentCanvas,\r\n                        INTERMEDIATE_OUTPUT_PREFIX + i,\r\n                        card.processingOptions,\r\n                        functionToRun);\r\n                } catch (err) {\r\n                    console.error(`Error using algorithm of id ${card.id}, error message: ${resolveOpenCVErrorNumber(err)}`);\r\n                }\r\n            }\r\n\r\n        }, DELAY);\r\n\r\n        return () => clearInterval(interval);\r\n    });\r\n\r\n    const videoConstraints = {\r\n        width: 1280,\r\n        height: 720,\r\n        facingMode: \"user\"\r\n    };\r\n    const webcamRef = React.useRef(null);\r\n\r\n    let [cards, setCards] = useState(InitialCardStates);\r\n\r\n    // entry point for image processing\r\n    const onUserMedia = () => {\r\n        window.webcam = webcamRef.current;\r\n    };\r\n\r\n    return (\r\n        <div className=\"App\">\r\n            <div className={\"processing-interface\"}>\r\n                {/* video pipeline shows the input from the camera detected and all intermediate outputs from each stage */}\r\n                <div className={\"video-pipeline\"}>\r\n                    <h2>Video Input and Intermediate Outputs (in order from top to bottom)</h2>\r\n                    <Webcam\r\n                        audio={false}\r\n                        ref={webcamRef}\r\n                        screenshotFormat=\"image/jpeg\"\r\n                        videoConstraints={videoConstraints}\r\n                        onUserMedia={onUserMedia}\r\n                    />\r\n                    <CanvasContainer\r\n                        cards={cards}\r\n                    />\r\n                </div>\r\n                {/* DndProvider needed for drag and drop functionality in AlgoContainer */}\r\n                <DndProvider backend={Backend}>\r\n                    <AlgoContainer\r\n                        cards={cards}\r\n                        setCards={setCards}\r\n                    />\r\n                </DndProvider>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}